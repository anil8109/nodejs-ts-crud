| Phase   | Focus                         |
| ------- | ----------------------------- |
| Phase 0 | CI + PR checks + coverage     |
| Phase 1 | Architecture + SOLID + DI     |
| Phase 2 | MongoDB + Repository pattern  | migrate-mongo
| Phase 3 | Advanced Jest (mocks, spies)  |
| Phase 4 | Linting + Type-check gates    |
| Phase 5 | Docker                        |
| Phase 6 | AWS EC2                       |
| Phase 7 | Horizontal scaling (EB / ALB) |


Phase -0

STEP 1ï¸âƒ£ â€“ Initialize Project
    mkdir nodejs-ts-crud
    cd nodejs-ts-crud

    npm init -y
STEP 2ï¸âƒ£ â€“ Install Core Dependencies
    npm install express
    npm install -D \
    typescript \
    ts-node \
    nodemon \
    eslint \
    prettier \
    jest \
    ts-jest \
    @types/jest \
    @types/node \
    @types/express


STEP 3ï¸âƒ£ â€“ TypeScript Configuration (CRITICAL)
    tsconfig.json

    {
    "compilerOptions": {
        "target": "ES2020",
        "module": "CommonJS",
        "rootDir": "src",
        "outDir": "dist",

        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,

        "esModuleInterop": true,
        "resolveJsonModule": true,

        "baseUrl": "./src",
        "paths": {
        "@/*": ["*"]
        }
    },
    "include": ["src"],
    "exclude": ["node_modules", "dist"]
    }

    ğŸ“Œ Why this matters

    strict: true â†’ forces better design
    Absolute imports (@/) â†’ cleaner architecture
    Fewer runtime surprises

STEP 4ï¸âƒ£ â€“ Base Folder Structure
    Create this now, even if empty:

    src/
    â”œâ”€â”€ app.ts
    â”œâ”€â”€ server.ts

    â”œâ”€â”€ config/
    â”œâ”€â”€ shared/
    â”œâ”€â”€ modules/
    â”œâ”€â”€ middlewares/

    tests/

    ğŸ“Œ This ensures architecture-first, not code-first.

STEP 5ï¸âƒ£ â€“ Jest Setup (WITH 100% ENFORCEMENT)
    jest.config.ts

    import type { Config } from 'jest';

    const config: Config = {
    preset: 'ts-jest',
    testEnvironment: 'node',

    roots: ['<rootDir>/src', '<rootDir>/tests'],

    collectCoverage: true,
    collectCoverageFrom: [
        'src/**/*.ts',
        '!src/server.ts'
    ],

    coverageThreshold: {
        global: {
        branches: 100,
        functions: 100,
        lines: 100,
        statements: 100
        }
    }
    };

    export default config;

    ğŸ“Œ This is the heart of discipline
    One uncovered line = âŒ build fail
    This is how real teams enforce quality

STEP 6ï¸âƒ£ â€“ Add NPM Scripts
    package.json

    {
    "scripts": {
        "dev": "nodemon src/server.ts",
        "build": "tsc",
        "lint": "eslint .",
        "test": "jest",
        "test:ci": "jest --runInBand",
        "coverage": "jest --coverage"
    }
    }

    ğŸ“Œ test:ci is slower but stable for pipelines

STEP 7ï¸âƒ£ â€“ Dummy App Code (Minimal)
    src/app.ts

    import express from 'express';

    export const app = express();

    app.use(express.json());

    app.get('/health', (_req, res) => {
    res.status(200).json({ status: 'ok' });
    });

    src/server.ts
    import { app } from './app';

    const PORT = 3000;

    app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    });

STEP 8ï¸âƒ£ â€“ FIRST TEST (Pipeline Validation)
    tests/health.test.ts
    import request from 'supertest';
    import { app } from '../src/app';

    describe('Health check', () => {
    it('should return 200', async () => {
        const res = await request(app).get('/health');

        expect(res.status).toBe(200);
        expect(res.body.status).toBe('ok');
    });
    });

    ğŸ‘‰ Now run:
    npm test

        âœ… Coverage should be 100%
        âŒ If not â†’ we fix, not ignore

STEP 9ï¸âƒ£ â€“ GitHub Actions (CI PIPELINE)
    .github/workflows/ci.yml

    name: CI

    on:
    pull_request:
        branches: [main]

    jobs:
    build-and-test:
        runs-on: ubuntu-latest

        steps:
        - name: Checkout code
            uses: actions/checkout@v4

        - name: Setup Node
            uses: actions/setup-node@v4
            with:
            node-version: 18

        - name: Install dependencies
            run: npm ci

        - name: Run tests with coverage
            run: npm run test:ci

    ğŸ“Œ If tests or coverage fail â†’ PR âŒ

STEP ğŸ”Ÿ â€“ GitHub Branch Protection (MANUAL BUT REQUIRED)

    On GitHub:

    Repo â†’ Settings
    Branches â†’ Add rule
    Branch name: main
    Enable:
    âœ… Require pull request
    âœ… Require status checks
    âœ… Select CI
    âŒ No force push
    âŒ No direct push
    ğŸ”¥ Now bad code physically cannot merge

ğŸ§  What You Just Achieved (Very Important)

    You now have:

    âœ” Real CI discipline
    âœ” Coverage gate
    âœ” PR enforcement
    âœ” Test-first mindset
    âœ” Company-grade foundation

    Most devs never do this properly.

npm install -D supertest @types/supertest


ğŸ”¹ STEP A â€“ Create GitHub Repository
Go to GitHub
Click New Repository
Repository name:
nodejs-ts-crud


Visibility: Private or Public (your choice)
âŒ Do NOT add README
âŒ Do NOT add .gitignore
âŒ Do NOT add license
Click Create Repository

ğŸ”¹ STEP B â€“ Initialize Git Locally
Inside your project folder:
git init
git branch -M main
git remote add origin https://github.com/<your-username>/nodejs-ts-crud.git
git remote -v
git add .

change to make workflow file visible in github temp2.
change to make workflow file visible in github temp2.
npm install -D mongodb-memory-server
